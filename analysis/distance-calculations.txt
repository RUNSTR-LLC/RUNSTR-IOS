27:    var distance: Double // meters
33:    var route: [CLLocationCoordinate2D]?
46:    var locations: [CLLocationCoordinate2D] {
51:        // Generate splits based on distance (1km splits)
52:        guard distance > 1000 else { return [] }
54:        let kmDistance = distance / 1000
64:                distance: 1000,
83:        let center = CLLocationCoordinate2D(
103:        self.distance = 0
126:         distance: Double, 
133:         locations: [CLLocationCoordinate2D] = [],
145:        self.distance = distance
149:        let kmDistance = distance / 1000
155:        print("   Distance: \(distance) meters (\(kmDistance) km)")
187:    var distanceFormatted: String {
190:            return String(format: "%.2f km", distance / 1000)
192:            let miles = distance * 0.000621371 // Convert meters to miles
207:    var distanceInPreferredUnits: Double {
210:            return distance / 1000 // Convert meters to km
212:            return distance * 0.000621371 // Convert meters to miles
240:    /// Get formatted distance using unit preferences
242:    func distanceFormatted(unitService: UnitPreferencesService) -> String {
243:        return unitService.formatDistance(distance)
252:    /// Get distance value in preferred units
254:    func distanceInPreferredUnits(unitService: UnitPreferencesService) -> Double {
255:        return unitService.convertDistance(distance)
264:    /// Get distance unit abbreviation
266:    func distanceUnit(unitService: UnitPreferencesService) -> String {
267:        return unitService.distanceUnit
278:        case id, userID, activityType, startTime, endTime, duration, distance, averagePace, calories
291:        distance = try container.decode(Double.self, forKey: .distance)
312:                return CLLocationCoordinate2D(latitude: lat, longitude: lon)
327:        try container.encode(distance, forKey: .distance)
364:    let distance: Double // meters
372:    let distance: Double // meters (actual distance covered for current split)
377:    var distanceFormatted: String {
380:            return String(format: "%.2f km", distance / 1000)
382:            let miles = distance * 0.000621371
418:    @Published var locations: [CLLocation] = []
483:            // Set split distance based on unit preference
584:            workout.distance = currentDistance  // HealthKit provides validated data
598:        print("‚úÖ Workout ended - Distance: \(String(format: "%.2f", workout.distance/1000))km, Duration: \(formatTime(workout.duration))")
610:        // Use HealthKit as the ONLY source for distance and steps
614:            // Use HealthKit distance exclusively
617:            // Calculate pace based on current distance and elapsed time
628:            // Update splits when distance changes
708:                    distance: splitDistance,
733:            distance: currentSplitDistance,
752:    /// No longer needed - HealthKit provides validated distance
753:    private func validateDistance(_ distance: Double, duration: TimeInterval) -> Double {
754:        guard distance > 0 && duration > 0 else { return 0 }
773:        if distance > maxPossibleDistance {
774:            print("‚ö†Ô∏è Distance validation failed: \(String(format: "%.0f", distance))m exceeds max possible \(String(format: "%.0f", maxPossibleDistance))m")
775:            print("   Capping distance at maximum reasonable value")
779:        // Also check for minimum reasonable speed (avoid 0 distance for active workouts)
783:        if duration > 60 && distance < minPossibleDistance {
784:            print("‚ö†Ô∏è Distance seems too low: \(String(format: "%.0f", distance))m for \(String(format: "%.1f", duration/60)) minutes")
787:        return distance
806:    /// Validate steps count based on distance
807:    private func validateSteps(_ steps: Int, distance: Double) -> Int {
808:        guard steps >= 0 && distance > 0 else { return 0 }
814:        let maxPossibleSteps = Int(distance / minStrideLength)
815:        let minPossibleSteps = Int(distance / maxStrideLength)
818:            print("‚ö†Ô∏è Steps validation: \(steps) exceeds max possible \(maxPossibleSteps) for distance \(String(format: "%.0f", distance))m")
823:            print("‚ö†Ô∏è Steps seem too low: \(steps) for distance \(String(format: "%.0f", distance))m")
164:        totalDistance += workout.distance
188:    /// Get formatted total distance (legacy - use formattedTotalDistance(unitService:) instead)
194:    /// Get formatted total distance using unit preferences
200:    /// Get average distance per workout
43:            "distance": workout.distance,
142:    let goalType: String // "distance_total", "streak_days", etc.
213:    let distance: Double?
214:    let distanceUnit: String?
235:        if let distanceTag = tags.first(where: { $0.first == "distance" && $0.count > 1 }),
236:           let distance = Double(distanceTag[1]) {
237:            self.distance = distance
238:            self.distanceUnit = distanceTag.count > 2 ? distanceTag[2] : "km"
240:            self.distance = nil
241:            self.distanceUnit = nil
274:        if let distance = distance, let unit = distanceUnit {
275:            tags.append(["distance", String(distance), unit])
313:        let distance: Double // km
328:              let distance = Double(exerciseTag[3]),
345:            distance: distance,
121:                Text(unitPreferences.distanceUnit)
448:            print("   üìè Distance: \(String(format: "%.2f", workout.distance/1000))km")
461:    let distance: Double // in meters
492:                Text(unitPreferences.formatDistance(distance, precision: 1))
71:        stats.totalDistance = allWorkouts.reduce(0) { $0 + $1.distance }
296:            // Total distance
28:                center: CLLocationCoordinate2D(latitude: 37.7749, longitude: -122.4194),
141:                value: workout.distanceFormatted,
323:        // Calculate speed from distance and duration
325:        let speedKmh = workout.distance / 1000 / (workout.duration / 3600)
366:        üìè Distance: \(workout.distanceFormatted)
376:            let speedKmh = workout.distance / 1000 / (workout.duration / 3600)
546:                        Text("üìè Distance: \(workout.distanceFormatted)")
584:                    üìè Distance: \(workout.distanceFormatted)
595:                        let speedKmh = workout.distance / 1000 / (workout.duration / 3600)
653:                    üìè Distance: \(workout.distanceFormatted)
726:        workout.distance = 5200 // 5.2km
35:                            value: workout.distanceFormatted,
115:        // Calculate speed from distance and duration
117:        let speedKmh = workout.distance / 1000 / (workout.duration / 3600)
162:            distance: 5000,
52:        case .distanceDescending:
53:            return workouts.sorted { $0.distance > $1.distance }
306:    case distanceDescending
313:        case .distanceDescending: return "Longest Distance"
21:        center: CLLocationCoordinate2D(latitude: 37.7749, longitude: -122.4194),
288:                    Text(currentSplit.distanceFormatted)
498:        print("üèÉ‚Äç‚ôÇÔ∏è Distance: \(String(format: "%.2f", workout.distance/1000))km")
563:            print("   üìè Distance: \(String(format: "%.2f", workout.distance/1000))km")
104:                value: String(format: "%.2f", workout.distanceInPreferredUnits(unitService: unitPreferences)),
105:                unit: workout.distanceUnit(unitService: unitPreferences)
400:        distance: 5000,
37:                        Text(workout.distanceFormatted(unitService: unitPreferences))
97:                distance: 5000, // 5km
110:                distance: 15000, // 15km
19:    /// Convert meters to preferred distance unit
28:    /// Get distance unit abbreviation
29:    var distanceUnit: String {
33:    /// Format distance with appropriate units
36:        return String(format: "%.\(precision)f \(distanceUnit)", convertedDistance)
34:        // Check for duplicates based on start time and distance (within tolerance)
37:            let distanceDifference = abs(existingWorkout.distance - workout.distance)
40:            return timeDifference < 60 && distanceDifference < 10
46:            print("‚úÖ Workout saved locally: \(workout.distanceFormatted), \(workout.durationFormatted)")
51:            print("‚ö†Ô∏è Duplicate workout detected, not saving: \(workout.distanceFormatted), \(workout.durationFormatted)")
94:        let totalDistance = workouts.reduce(0.0) { $0 + $1.distance }
119:                longestDistance: typeWorkouts.max { $0.distance < $1.distance },
278:    /// Get formatted distance using unit preferences
54:    func distanceMilestone() {
31:    private var distanceQuery: HKStatisticsQuery?
39:        HKQuantityType.quantityType(forIdentifier: .distanceWalkingRunning)!,
40:        HKQuantityType.quantityType(forIdentifier: .distanceCycling)!,
49:        HKQuantityType.quantityType(forIdentifier: .distanceWalkingRunning)!,
50:        HKQuantityType.quantityType(forIdentifier: .distanceCycling)!,
181:                    let distanceQuantity = HKQuantity(unit: .meter(), doubleValue: workout.distance)
182:                    let distanceSample = HKQuantitySample(type: HKQuantityType(.distanceWalkingRunning), 
183:                                                        quantity: distanceQuantity, 
187:                        builder.add([distanceSample]) { success, error in
231:                totalDistance: HKQuantity(unit: .meter(), doubleValue: workout.distance),
263:        if let distanceQuery = distanceQuery {
264:            healthStore.stop(distanceQuery)
265:            self.distanceQuery = nil
363:        // Use appropriate distance type based on activity
364:        let distanceType = HKQuantityType.quantityType(forIdentifier: .distanceWalkingRunning)!
370:        distanceQuery = HKStatisticsQuery(
371:            quantityType: distanceType,
378:                print("‚ùå HealthKit distance query error: \(error.localizedDescription)")
393:        if let query = distanceQuery {
407:        if let oldQuery = distanceQuery {
412:        let distanceType = HKQuantityType.quantityType(forIdentifier: .distanceWalkingRunning)!
417:        distanceQuery = HKStatisticsQuery(
418:            quantityType: distanceType,
425:                print("‚ùå HealthKit distance refresh error: \(error.localizedDescription)")
438:        if let query = distanceQuery {
181:        üìè Distance: \(workout.distanceFormatted)
191:            let speedKmh = workout.distance / 1000 / (workout.duration / 3600)
784:              let distance = workoutDict["distance"] as? Double else {
801:        var route: [CLLocationCoordinate2D]? = nil
805:                return CLLocationCoordinate2D(latitude: lat, longitude: lon)
814:            distance: distance,
6:    private let locationManager = CLLocationManager()
8:    @Published var currentLocation: CLLocation?
10:    @Published var route: [CLLocation] = []
12:    @Published var currentSpeed: Double = 0.0 // m/s (for display only, not used for distance)
20:    private var lastLocation: CLLocation?
30:    // These were causing distance tracking to stop mid-workout
59:    // Additional smoothing for distance calculation
60:    private var locationHistory: [CLLocation] = []
70:        locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation
71:        locationManager.distanceFilter = minimumDistance
128:        locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation
129:        locationManager.distanceFilter = minimumDistance
192:    // Removed averagePace - now calculated from HealthKit distance only
194:    var routeCoordinates: [CLLocationCoordinate2D] {
253:        let placemark = MKPlacemark(coordinate: route.first?.coordinate ?? CLLocationCoordinate2D())
282:    /// Get smoothed distance using location history and weighted positioning
283:    private func getSmoothedDistance(from newLocation: CLLocation, to lastLocation: CLLocation) -> Double {
292:        // For early locations, use simple distance
294:            return newLocation.distance(from: lastLocation)
298:        let baseDistance = newLocation.distance(from: lastLocation)
300:        // If accuracy is good, use direct distance
320:        let smoothedCoordinate = CLLocationCoordinate2D(latitude: weightedLat, longitude: weightedLon)
321:        let smoothedLocation = CLLocation(coordinate: smoothedCoordinate, 
327:        return smoothedLocation.distance(from: lastLocation)
331:extension LocationService: CLLocationManagerDelegate {
332:    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
355:        // Check minimum distance and time requirements
357:            let distance = location.distance(from: lastLoc)
361:            guard distance >= minimumDistance || timeInterval >= minimumTimeInterval else {
366:            let rawCalculatedSpeed = timeInterval > 0 ? distance / timeInterval : 0.0
368:            // Use CLLocation's built-in speed if available and valid, otherwise use calculated
371:                // CLLocation provides reliable speed measurement
399:                    // Continue tracking but log it - don't stop distance accumulation
409:            // Only update speed for display purposes (not used for distance)
435:    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
465:    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
11:    let distance: Double // in meters
39:    Workout(distance: 5950, duration: 1800, startTime: Date()),
42:    Workout(distance: 3200, duration: 1200, startTime: Calendar.current.date(byAdding: .day, value: -1, to: Date())!),
45:    Workout(distance: 4800, duration: 1500, startTime: Calendar.current.date(byAdding: .day, value: -2, to: Date())!),
48:    Workout(distance: 2400, duration: 900, startTime: Calendar.current.date(byAdding: .day, value: -4, to: Date())!),
51:    Workout(distance: 1600, duration: 600, startTime: Calendar.current.date(byAdding: .day, value: -5, to: Date())!),
54:    Workout(distance: 5950, duration: 2100, startTime: Calendar.current.date(byAdding: .day, value: -6, to: Date())!)
60:    stats.totalDistance = workouts.reduce(0) { $0 + $1.distance }
